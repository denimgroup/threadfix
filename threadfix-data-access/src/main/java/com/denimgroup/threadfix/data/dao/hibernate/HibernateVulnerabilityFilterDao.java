////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2015 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.data.dao.hibernate;

import com.denimgroup.threadfix.data.dao.VulnerabilityFilterDao;
import com.denimgroup.threadfix.data.entities.*;
import com.denimgroup.threadfix.logging.SanitizedLogger;
import org.hibernate.Criteria;
import org.hibernate.Query;
import org.hibernate.SessionFactory;
import org.hibernate.criterion.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Map;

import static com.denimgroup.threadfix.CollectionUtils.join;
import static com.denimgroup.threadfix.CollectionUtils.list;
import static org.hibernate.criterion.Restrictions.eq;

@Repository
public class HibernateVulnerabilityFilterDao implements VulnerabilityFilterDao {

	private SessionFactory sessionFactory;

	private static final SanitizedLogger LOG = new SanitizedLogger(HibernateVulnerabilityFilterDao.class);

	@Autowired
	public HibernateVulnerabilityFilterDao(SessionFactory sessionFactory) {
		this.sessionFactory = sessionFactory;
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllGlobal() {
		return getBaseCriteria()
				.add(eq("global", true))
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll() {
		return getBaseCriteria().list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll(int orgId) {
		return getBaseCriteria()
				.add(eq("organization.id", orgId))
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAll(int orgId, int appId) {
		return getBaseCriteria()
				.add(eq("application.id", appId))
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllEffective(int orgId) {
		return getBaseCriteria()
				.add(Restrictions.disjunction()
								.add(eq("organization.id", orgId))
								.add(eq("global", true))
				)
				.list();
	}

	@SuppressWarnings("unchecked")
	@Override
	public List<VulnerabilityFilter> retrieveAllEffective(int orgId, int appId) {
		return getBaseCriteria()
				.add(Restrictions.disjunction()
								.add(eq("application.id", appId))
								.add(eq("organization.id", orgId))
								.add(eq("global", true))
				)
				.list();
	}

	@Override
	public VulnerabilityFilter retrieveById(int vulnFilterId) {
		return (VulnerabilityFilter) getBaseCriteria()
				.add(eq("id", vulnFilterId))
				.uniqueResult();
	}

	@Override
	public VulnerabilityFilter retrieveByVulnerabilityAndType(
			int sourceGenericVulnerabilityId, VulnerabilityFilter filter) {

		VulnerabilityFilter returnFilter = null;
		if (filter != null) {
			Criteria criteria = getBaseCriteria()
					.add(eq("sourceGenericVulnerability.id", sourceGenericVulnerabilityId));

			if (filter.getOrganization() != null) {
				criteria.add(eq("organization.id", filter.getOrganization().getId()));
			} else if (filter.getApplication() != null) {
				criteria.add(eq("application.id", filter.getApplication().getId()));
			} else {
				criteria.add(eq("global", true));
			}

			returnFilter = (VulnerabilityFilter) criteria.uniqueResult();
		}

		return returnFilter;
	}

	private Criteria getBaseCriteria() {
		return sessionFactory.getCurrentSession()
				.createCriteria(VulnerabilityFilter.class)
				.add(eq("active", true));
	}

	@Override
	public void saveOrUpdate(VulnerabilityFilter vulnerabilityFilter) {
		if (vulnerabilityFilter != null && vulnerabilityFilter.getId() != null) {
			sessionFactory.getCurrentSession().merge(vulnerabilityFilter);
		} else {
			sessionFactory.getCurrentSession().saveOrUpdate(vulnerabilityFilter);
		}
	}

	@Override
	public void delete(int filterId) {
		VulnerabilityFilter filter = retrieveById(filterId);
		if (filter != null) {
			sessionFactory.getCurrentSession().delete(filter);
		}
	}

	@Override
	public void applyFilterToApplication(Integer applicationId, VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			int updated = sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true " +
							"where vulnerability.genericVulnerability = :genericVulnerability " +
							"and vulnerability.application.id = :application")
					.setParameter("application", applicationId)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
			LOG.debug("Updated " + updated + " records for filter " + filter);
		} else {

			String subquery = "(select vulnerabilityId from StatisticsCounter counter " +
					"where counter.genericVulnerabilityId = :genericVulnerability " +
					"and counter.finding.scan.application.id = :application)";

			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set genericSeverity = :genericSeverity where id in " + subquery)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability().getId())
					.setParameter("application", applicationId)
					.setParameter("genericSeverity", filter.getTargetGenericSeverity())
					.executeUpdate();

			subquery = "(select id from Vulnerability vulnerability " +
					"where vulnerability.genericVulnerability = :genericVulnerability " +
					"and vulnerability.application.id = :application)";

			sessionFactory.getCurrentSession().createQuery(
					"update StatisticsCounter counter set currentGenericSeverityId = :genericSeverityId where vulnerabilityId in " + subquery)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.setParameter("application", applicationId)
					.setParameter("genericSeverityId", filter.getTargetGenericSeverity().getId())
					.executeUpdate();
		}
	}

	@Override
	public void resetHiddenForApplication(Integer applicationId) {
		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = false " +
						"where vulnerability.application.id = :application")
				.setParameter("application", applicationId)
				.executeUpdate();
	}

	@Override
	public void resetHiddenForTeam(Integer teamId) {
		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = false " +
						"where vulnerability.application in (select id from Application where organization.id = :teamId)")
				.setParameter("teamId", teamId)
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterToApplication(Integer applicationId, SeverityFilter severityFilter) {
		hideSeverityApplication(applicationId, 5, severityFilter.getShowCritical());
		hideSeverityApplication(applicationId, 4, severityFilter.getShowHigh());
		hideSeverityApplication(applicationId, 3, severityFilter.getShowMedium());
		hideSeverityApplication(applicationId, 2, severityFilter.getShowLow());
		hideSeverityApplication(applicationId, 1, severityFilter.getShowInfo());
	}

	private void hideSeverityApplication(Integer applicationId, Integer intValue, boolean shouldShow) {

		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = " + !shouldShow +
						" where id in (select vulnerabilityId from StatisticsCounter counter " +
						"where counter.currentGenericSeverityId = " +
						"(select id from GenericSeverity where intValue = :intValue) " +
						"and counter.finding.scan.application.id = :application)")
				.setParameter("intValue", intValue)
				.setParameter("application", applicationId)
				.executeUpdate();
	}

	@Override
	public void resetHiddenAll() {
		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = false")
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterGlobal(SeverityFilter severityFilter) {
		if (!severityFilter.getShowCritical()) {
			hideSeverityGlobal(5);
		}
		if (!severityFilter.getShowHigh()) {
			hideSeverityGlobal(4);
		}
		if (!severityFilter.getShowMedium()) {
			hideSeverityGlobal(3);
		}
		if (!severityFilter.getShowLow()) {
			hideSeverityGlobal(2);
		}
		if (!severityFilter.getShowInfo()) {
			hideSeverityGlobal(1);
		}
	}

	private void hideSeverityGlobal(int intValue) {

		GenericSeverity severity = (GenericSeverity) sessionFactory.getCurrentSession()
				.createCriteria(GenericSeverity.class)
				.add(eq("intValue", intValue))
				.uniqueResult();

		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = true where vulnerability.genericSeverity = :severity")
				.setParameter("severity", severity)
				.executeUpdate();
	}

	@Override
	public void applySeverityFilterToTeam(Integer id, SeverityFilter severityFilter) {
		hideSeverityTeam(id, 5, severityFilter.getShowCritical());
		hideSeverityTeam(id, 4, severityFilter.getShowHigh());
		hideSeverityTeam(id, 3, severityFilter.getShowMedium());
		hideSeverityTeam(id, 2, severityFilter.getShowLow());
		hideSeverityTeam(id, 1, severityFilter.getShowInfo());
	}

	private void hideSeverityTeam(int teamId, int intValue, boolean shouldShow) {

		sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = " + !shouldShow +
						" where id in (select vulnerabilityId from StatisticsCounter counter " +
						"where counter.finding.scan.application.id in " +
						"(select id from Application where organization.id = :team) " +
						"and counter.currentGenericSeverityId = " +
						"(select id from GenericSeverity where intValue = :intValue))")
				.setParameter("intValue", intValue)
				.setParameter("team", teamId)
				.executeUpdate();
	}

	@Override
	public void applyFilterGlobal(VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true " +
							"where vulnerability.genericVulnerability = :genericVulnerability")
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		} else {

			String subquery = "(select vulnerabilityId from StatisticsCounter counter " +
					"where genericVulnerabilityId = :genericVulnerability)";

			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability " +
							"set genericSeverity = :genericSeverity " +
							"where id in " + subquery)
					.setParameter("genericSeverity", filter.getTargetGenericSeverity())
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability().getId())
					.executeUpdate();

			subquery = "(select id from Vulnerability vulnerability " +
					"where vulnerability.genericVulnerability = :genericVulnerability)";

			sessionFactory.getCurrentSession().createQuery(
					"update StatisticsCounter counter " +
							"set currentGenericSeverityId = :genericSeverityId " +
							"where vulnerabilityId in " + subquery)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.setParameter("genericSeverityId", filter.getTargetGenericSeverity().getId())
					.executeUpdate();
		}
	}

	@Override
	public void applyFilterToTeam(Integer id, VulnerabilityFilter filter) {
		if (filter.getTargetGenericSeverity() == null) {
			sessionFactory.getCurrentSession().createQuery(
					"update Vulnerability vulnerability set hidden = true " +
							"where vulnerability.genericVulnerability = :genericVulnerability " +
							"and vulnerability.application in " +
							"(select id from Application where organization.id = :teamId)")
					.setParameter("teamId", id)
					.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
					.executeUpdate();
		} else {

			String subquery = "(select vulnerabilityId from StatisticsCounter counter " +
							"where counter.genericVulnerabilityId = :genericVulnerability " +
							"and counter.finding.scan.application.id in " +
							"(select id from Application where organization.id = :teamId))";

			sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability " +
						"set genericSeverity = :genericSeverity " +
						"where id in " + subquery)
				.setParameter("genericSeverity", filter.getTargetGenericSeverity())
				.setParameter("genericVulnerability", filter.getSourceGenericVulnerability().getId())
				.setParameter("teamId", id)
				.executeUpdate();

			subquery = "(select id from Vulnerability vulnerability " +
					"where vulnerability.genericVulnerability = :genericVulnerability " +
					"and vulnerability.application.id in " +
					"(select id from Application where organization.id = :teamId))";

			sessionFactory.getCurrentSession().createQuery(
				"update StatisticsCounter counter " +
						"set currentGenericSeverityId = :genericSeverityId " +
						"where vulnerabilityId in " + subquery)
				.setParameter("genericVulnerability", filter.getSourceGenericVulnerability())
				.setParameter("teamId", id)
				.setParameter("genericSeverityId", filter.getTargetGenericSeverity().getId())
				.executeUpdate();
		}
	}

	private String getIgnoredIdHQL(List<Integer> filteredSeverities, List<Integer> filteredVulnerabilities) {

		String base = "(select id from Vulnerability ",
				genericSeverity = " genericSeverity.id in (:filteredSeverities)",
				genericVulnerability = " genericVulnerability.id in (:filteredVulnerabilities)";

		if (!filteredSeverities.isEmpty() && !filteredVulnerabilities.isEmpty()) {
			return base + " where" + genericSeverity + " and" + genericVulnerability + ") ";

		} else if (!filteredSeverities.isEmpty()) {
			return base + " where" + genericSeverity + ") ";

		} else if (!filteredVulnerabilities.isEmpty()) {
			return base + " where" + genericVulnerability + ") ";

		} else {
			// if there are no filtered severities or types, return an empty list
			return null;
		}
	}

	@Override
	public List<Map<String, Object>> getScanClosedVulnerabilitiesMap(List<Integer> filteredSeverities,
																	 List<Integer> filteredVulnerabilities) {
		return runInnerMapQuery(filteredSeverities, filteredVulnerabilities, ScanCloseVulnerabilityMap.class);
	}

	@Override
	public List<Map<String, Object>> getScanReopenedVulnerabilitiesMap(List<Integer> filteredSeverities,
																	   List<Integer> filteredVulnerabilities) {
		return runInnerMapQuery(filteredSeverities, filteredVulnerabilities, ScanReopenVulnerabilityMap.class);
	}


	private List<Map<String, Object>> runInnerMapQuery(List<Integer> filteredSeverities,
													   List<Integer> filteredVulnerabilities,
													   Class<?> targetClass) {

		String className = targetClass.getName();

		String hql = "select new map (" +
				"count(*) as total, " +
				"closeMap.scan.id as scanId) " +
				"from " + className + " closeMap ";

		String filteredIDClause = getIgnoredIdHQL(filteredSeverities, filteredVulnerabilities);

		if (filteredIDClause != null) {
			hql += "where vulnerability.id not in " + filteredIDClause;
		}

		hql += "group by closeMap.scan.id";

		Query query = sessionFactory.getCurrentSession().createQuery(hql);

		if (!filteredSeverities.isEmpty()) {
			query.setParameterList("filteredSeverities", filteredSeverities);
		}

		if (!filteredVulnerabilities.isEmpty()) {
			query.setParameterList("filteredVulnerabilities", filteredVulnerabilities);
		}

		Object idsMap = query.list();

		return (List<Map<String, Object>>) idsMap;
	}

	@Override
	public void hideForScanResultFilter(ScanResultFilter scanResultFilter, Application application) {
		String subquery = getVulnsToHideSubquery(scanResultFilter, null, application, 0);

		Query query = sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability set hidden = true where vulnerability.id in " + subquery)
				.setParameter("genericSeverityIntValue0", scanResultFilter.getGenericSeverity().getIntValue())
				.setParameter("channelTypeId0", scanResultFilter.getChannelType().getId());

		if (application != null) {
			query.setParameter("applicationId0", application.getId());
		}

		query.executeUpdate();
	}

	@Override
	public String getVulnsToHideSubquery(ScanResultFilter scanResultFilter,
										 Scan scan,
										 Application application,
										 int index) {
		assert scanResultFilter != null;
		assert scanResultFilter.getChannelType() != null;
		assert scanResultFilter.getGenericSeverity() != null;

		/*
		There are two conditions to hide vulns:
		1. ChannelSeverity in Finding maps to GenericSeverity in ScanResultFilter
		2. Vulns of those Finding Ids found in step 1 have the same GenericSeverity in ScanResultFilter
		(to avoid Vulns that users changed its severity manually or with more than one finding in Vulns)
		 */

		String base = "(select id from Finding where";

		List<String> whereConditions = list();

		if (scan != null) {
			whereConditions.add(" scan.id = :scanId" + index);
		}
		if (application != null) {
			whereConditions.add(" scan.application.id = :applicationId" + index);
		}

		whereConditions.add(" channelSeverity.severityMap.genericSeverity.intValue = :genericSeverityIntValue" + index +
				" and scan.applicationChannel.channelType.id = :channelTypeId" + index + ")");

		base += join(" and", whereConditions);

		String secondQuery =
				"(select finding.vulnerability.id from Finding finding where finding.id in " + base +
				" and finding.vulnerability.genericSeverity.intValue = :genericSeverityIntValue" + index + ")";

		return secondQuery;
	}

	@Override
	public VulnerabilityFilter find(GenericVulnerability sourceGenericVulnerability, int orgId, int appId) {
		Criteria criteria = sessionFactory
				.getCurrentSession()
				.createCriteria(VulnerabilityFilter.class)
				.createAlias("sourceGenericVulnerability", "genericAlias")
				.add(eq("genericAlias.id", sourceGenericVulnerability.getId()));

		if (orgId != -1) {
			criteria.createAlias("organization", "organizationAlias")
					.add(eq("organizationAlias.id", orgId));
		} else if (appId != -1) {
			criteria.createAlias("application", "applicationAlias")
					.add(eq("applicationAlias.id", appId));
		} else {
			criteria.add(eq("global", true));
		}


		List list = criteria.list();

		if (list.size() > 0) {
			return (VulnerabilityFilter) list.get(0);
		} else {
			return null;
		}
	}

	@Override
	public void resetVulnFilterAffect(GenericVulnerability oldGenericVulnerability, int orgId, int appId) {

		// I would prefer to do this with Criteria but Criteria doesn't support updates.
		String counterSubquery = "(select vulnerabilityId " +
				"from StatisticsCounter counter " +
				"where counter.genericVulnerabilityId = :genericVulnerabilityId",
			vulnSubquery = "(select id " +
					"from Vulnerability vulnerability " +
					"where vulnerability.genericVulnerability.id = :genericVulnerabilityId";

		if (appId != -1) {
			counterSubquery += " and counter.finding.scan.application.id = :applicationId";
			vulnSubquery += " and vulnerability.application.id = :applicationId";
		}
		if (orgId != -1) {
			counterSubquery += " and counter.finding.scan.application.organization.id = :teamId";
			vulnSubquery += " and vulnerability.application.organization.id = :teamId";
		}

		counterSubquery += ")";
		vulnSubquery += ")";

		Query resetVuln = sessionFactory.getCurrentSession().createQuery(
				"update Vulnerability vulnerability " +
						"set genericSeverity = originalGenericSeverity " +
						"where vulnerability.id in " + counterSubquery);

		Query resetStatsCounter = sessionFactory.getCurrentSession().createQuery(
				"update StatisticsCounter counter " +
						"set currentGenericSeverityId = " +
						"(select originalGenericSeverity.id from Vulnerability vuln " +
						"where vuln.id = counter.vulnerabilityId) " +
						"where vulnerabilityId in " + vulnSubquery);

		for (Query query : new Query[] { resetVuln, resetStatsCounter }) {
			query.setParameter("genericVulnerabilityId", oldGenericVulnerability.getId());

			if (appId != -1) {
				query.setParameter("applicationId", appId);
			}
			if (orgId != -1) {
				query.setParameter("teamId", orgId);
			}

			query.executeUpdate();
		}

	}
}
