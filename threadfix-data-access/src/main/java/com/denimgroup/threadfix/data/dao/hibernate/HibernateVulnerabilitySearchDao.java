////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2015 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.data.dao.hibernate;

import com.denimgroup.threadfix.data.dao.VulnerabilitySearchDao;
import com.denimgroup.threadfix.data.entities.Vulnerability;
import com.denimgroup.threadfix.data.entities.VulnerabilitySearchParameters;
import com.denimgroup.threadfix.data.entities.VulnerabilitySearchPivotType;
import com.denimgroup.threadfix.data.entities.VulnerabilityTreeElement;
import org.hibernate.Criteria;
import org.hibernate.SessionFactory;
import org.hibernate.classic.Session;
import org.hibernate.criterion.Order;
import org.hibernate.criterion.ProjectionList;
import org.hibernate.criterion.Projections;
import org.hibernate.criterion.Restrictions;
import org.hibernate.transform.Transformers;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Repository;

import java.util.Date;
import java.util.List;
import java.util.Map;

import static com.denimgroup.threadfix.CollectionUtils.list;

/**
 * Created by mac on 5/7/14.
 */
@Repository
@SuppressWarnings("unchecked")
public class HibernateVulnerabilitySearchDao implements VulnerabilitySearchDao {

    @Autowired
    private SessionFactory sessionFactory;

    private Criteria performLookupSetup(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

        if (parameters.getNumberVulnerabilities() != null) {
            criteria.setMaxResults(parameters.getNumberVulnerabilities());
            if (parameters.getPage() != null)
                criteria.setFirstResult(parameters.getNumberVulnerabilities() * (parameters.getPage() - 1));
        }

        return criteria;
    }

    private void addOrders(VulnerabilitySearchParameters parameters, Criteria criteria) {
        for (String desc : parameters.getDescList()) {
            criteria.addOrder(Order.desc(desc));
        }
        if (parameters.getAscList() == null || parameters.getAscList().size() == 0)
            criteria.addOrder(Order.asc("surface.path"));
        else for (String asc: parameters.getAscList()) {
            criteria.addOrder(Order.asc(asc));
        }
    }

    @Override
    public List<Vulnerability> performLookup(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = performLookupSetup(parameters);

        // this is in this method and not the setup because it doesn't play nice with count
        addOrders(parameters, criteria);

        return (List<Vulnerability>) criteria.list();
    }

    @Override
    public long performLookupCount(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        Criteria criteria = performLookupSetup(parameters);

        Number numVulns = (Number) criteria.setProjection(Projections.rowCount()).uniqueResult();
        return numVulns.longValue();
    }

    @Override
    public List<VulnerabilityTreeElement> getTree(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        List<VulnerabilityTreeElement> treeElements = list();
        ProjectionList projectionList = Projections.projectionList()
                .add(Projections.countDistinct("id"), "numResults");

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT &&
                parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT ||
                parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT &&
                parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {

            treeElements = addDefectCommentProjections(parameters, projectionList, treeElements);

        } else if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT ||
                parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {

            treeElements = addDefectProjections(parameters, projectionList, treeElements);

        } else if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT ||
                parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT) {

            treeElements = addCommentProjections(parameters, projectionList, treeElements);

        } else {

            Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                    getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

            addGroupProperty(parameters, parameters.getPrimaryPivot(), list(criteria), projectionList, "primaryPivotName");
            addGroupProperty(parameters, parameters.getSecondaryPivot(), list(criteria), projectionList, "secondaryPivotName");

            treeElements = getTreeElements(parameters, criteria, projectionList);
        }

        return treeElements;
    }

    private List<VulnerabilityTreeElement> getTreeElements(VulnerabilitySearchParameters parameters,
                                                           Criteria criteria, ProjectionList projectionList) {
        criteria.setProjection(projectionList).addOrder(Order.desc("numResults"));
        addOrder(parameters.getPrimaryPivot(), criteria);
        addOrder(parameters.getSecondaryPivot(), criteria);
        criteria.setResultTransformer(Transformers.aliasToBean(VulnerabilityTreeElement.class));

        return (List<VulnerabilityTreeElement>) criteria.list();
    }

    private List<VulnerabilityTreeElement> addDefectCommentProjections(VulnerabilitySearchParameters parameters,
                                                                ProjectionList projectionList,
                                                                List<VulnerabilityTreeElement> treeElements) {

        Criteria hasDefectHasCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNotNull("defect"))
                .add(Restrictions.isNotEmpty("vulnerabilityComments"));

        Criteria hasDefectNoCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNotNull("defect"))
                .add(Restrictions.isEmpty("vulnerabilityComments"));

        Criteria noDefectHasCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNull("defect"))
                .add(Restrictions.isNotEmpty("vulnerabilityComments"));

        Criteria noDefectNoCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNull("defect"))
                .add(Restrictions.isEmpty("vulnerabilityComments"));

        List<VulnerabilityTreeElement> hasDefectHasCommentsTreeElements = getTreeElements(parameters, hasDefectHasCommentsCriteria, projectionList);
        List<VulnerabilityTreeElement> hasDefectNoCommentsTreeElements = getTreeElements(parameters, hasDefectNoCommentsCriteria, projectionList);
        List<VulnerabilityTreeElement> noDefectHasCommentsTreeElements = getTreeElements(parameters, noDefectHasCommentsCriteria, projectionList);
        List<VulnerabilityTreeElement> noDefectNoCommentsTreeElements = getTreeElements(parameters, noDefectNoCommentsCriteria, projectionList);

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {
            for (VulnerabilityTreeElement element: hasDefectHasCommentsTreeElements) {
                element.setPrimaryPivotName("Has Defect");
                element.setSecondaryPivotName("Has Comment");
            }
            for (VulnerabilityTreeElement element: hasDefectNoCommentsTreeElements) {
                element.setPrimaryPivotName("Has Defect");
                element.setSecondaryPivotName("No Comments");
            }
            for (VulnerabilityTreeElement element: noDefectHasCommentsTreeElements) {
                element.setPrimaryPivotName("No Defect");
                element.setSecondaryPivotName("Has Comment");
            }
            for (VulnerabilityTreeElement element: noDefectNoCommentsTreeElements) {
                element.setPrimaryPivotName("No Defect");
                element.setSecondaryPivotName("No Comments");
            }
        } else {
            for (VulnerabilityTreeElement element: hasDefectHasCommentsTreeElements) {
                element.setSecondaryPivotName("Has Defect");
                element.setPrimaryPivotName("Has Comment");
            }
            for (VulnerabilityTreeElement element: hasDefectNoCommentsTreeElements) {
                element.setSecondaryPivotName("Has Defect");
                element.setPrimaryPivotName("No Comments");
            }
            for (VulnerabilityTreeElement element: noDefectHasCommentsTreeElements) {
                element.setSecondaryPivotName("No Defect");
                element.setPrimaryPivotName("Has Comment");
            }
            for (VulnerabilityTreeElement element: noDefectNoCommentsTreeElements) {
                element.setSecondaryPivotName("No Defect");
                element.setPrimaryPivotName("No Comments");
            }
        }

        treeElements.addAll(hasDefectHasCommentsTreeElements);
        treeElements.addAll(hasDefectNoCommentsTreeElements);
        treeElements.addAll(noDefectHasCommentsTreeElements);
        treeElements.addAll(noDefectNoCommentsTreeElements);

        return treeElements;
    }

    private List<VulnerabilityTreeElement> addDefectProjections(VulnerabilitySearchParameters parameters,
                                                                ProjectionList projectionList,
                                                                List<VulnerabilityTreeElement> treeElements) {

        Criteria hasDefectCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNotNull("defect"));

        Criteria noDefectCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNull("defect"));

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {
            addGroupProperty(parameters, parameters.getSecondaryPivot(), list(hasDefectCriteria, noDefectCriteria),
                    projectionList, "secondaryPivotName");
        } else if (parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {
            addGroupProperty(parameters, parameters.getPrimaryPivot(), list(hasDefectCriteria, noDefectCriteria),
                    projectionList, "primaryPivotName");
        }

        List<VulnerabilityTreeElement> hasDefectTreeElements = getTreeElements(parameters, hasDefectCriteria, projectionList);
        List<VulnerabilityTreeElement> noDefectTreeElements = getTreeElements(parameters, noDefectCriteria, projectionList);

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {
            for (VulnerabilityTreeElement element: hasDefectTreeElements) {
                element.setPrimaryPivotName("Has Defect");
            }
            for (VulnerabilityTreeElement element: noDefectTreeElements) {
                element.setPrimaryPivotName("No Defect");
            }
        } else if (parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_DEFECT) {
            for (VulnerabilityTreeElement element: hasDefectTreeElements) {
                element.setSecondaryPivotName("Has Defect");
            }
            for (VulnerabilityTreeElement element: noDefectTreeElements) {
                element.setSecondaryPivotName("No Defect");
            }
        }

        treeElements.addAll(hasDefectTreeElements);
        treeElements.addAll(noDefectTreeElements);

        return treeElements;
    }

    private List<VulnerabilityTreeElement> addCommentProjections(VulnerabilitySearchParameters parameters,
                                                                 ProjectionList projectionList,
                                                                 List<VulnerabilityTreeElement> treeElements) {
        Criteria hasCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isNotEmpty("vulnerabilityComments"));

        Criteria noCommentsCriteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .add(Restrictions.isEmpty("vulnerabilityComments"));

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT) {
            addGroupProperty(parameters, parameters.getSecondaryPivot(), list(hasCommentsCriteria, noCommentsCriteria),
                    projectionList, "secondaryPivotName");
        } else if (parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT) {
            addGroupProperty(parameters, parameters.getPrimaryPivot(), list(hasCommentsCriteria, noCommentsCriteria),
                    projectionList, "primaryPivotName");
        }

        List<VulnerabilityTreeElement> hasCommentsTreeElements = getTreeElements(parameters, hasCommentsCriteria, projectionList);
        List<VulnerabilityTreeElement> noCommentsTreeElements = getTreeElements(parameters, noCommentsCriteria, projectionList);

        if (parameters.getPrimaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT) {
            for (VulnerabilityTreeElement element: hasCommentsTreeElements) {
                element.setPrimaryPivotName("Has Comments");
            }
            for (VulnerabilityTreeElement element: noCommentsTreeElements) {
                element.setPrimaryPivotName("No Comments");
            }
        } else if (parameters.getSecondaryPivot() == VulnerabilitySearchPivotType.HAS_COMMENT) {
            for (VulnerabilityTreeElement element: hasCommentsTreeElements) {
                element.setSecondaryPivotName("Has Comments");
            }
            for (VulnerabilityTreeElement element: noCommentsTreeElements) {
                element.setSecondaryPivotName("No Comments");
            }
        }

        treeElements.addAll(hasCommentsTreeElements);
        treeElements.addAll(noCommentsTreeElements);

        return treeElements;
    }

    private void addGroupProperty(VulnerabilitySearchParameters parameters,
                                  VulnerabilitySearchPivotType pivotType, List<Criteria> criterias,
                                  ProjectionList projectionList, String pivotPriority) {

        switch (pivotType) {
            case SEVERITY:
                projectionList.add(Projections.groupProperty("severity.name"), pivotPriority)
                              .add(Projections.groupProperty("severity.intValue"), "severityIntValue");
                break;
            case CWE:
                projectionList.add(Projections.groupProperty("genericVulnAlias.name"), pivotPriority);
                break;
            case PATH:
                projectionList.add(Projections.groupProperty("calculatedUrlPath"), pivotPriority);
                break;
            case SCANNER:
                projectionList.add(Projections.groupProperty("channelTypeAlias.name"), pivotPriority);
                break;
            case TAG:
                if (!parameters.getVulnTags().isEmpty()) {
                    for (Criteria criteria : criterias) {
                        criteria.createAlias("tags", "tagsAlias");
                    }
                    projectionList.add(Projections.groupProperty("tagsAlias.name"), pivotPriority);
                }
                break;
            default:
                break;
        }
    }

    private void addOrder(VulnerabilitySearchPivotType pivotType, Criteria criteria) {

        switch (pivotType) {
            case SEVERITY:
                criteria.addOrder(Order.desc("severityIntValue"));
                break;
            default:
                break;
        }
    }

    @Override
    public List<Object> getAges(VulnerabilitySearchParameters parameters) {
        assert parameters != null;

        List<Integer> idList = getVulnIdList(parameters);
        if (idList.isEmpty())
            return list();

        List<Object> result = sessionFactory.getCurrentSession()
                .createQuery(String.format("select new map( " +
                        "avg(%s) as datediff, " +
                        "vuln.genericSeverity.intValue as severity, vuln.genericSeverity.customName as severityCustomName, " +
                        "vuln.genericSeverity.name as severityName ) " +
                        "from Vulnerability vuln where vuln.id in (:idList) " +
                        "group by vuln.genericSeverity.intValue, vuln.genericSeverity.customName, vuln.genericSeverity.name",
                        getDateDiffSql(":current_timestamp", "vuln.openTime"))
                )
                .setDate("current_timestamp", new Date())
                .setParameterList("idList", idList)
                .list();

        return result;
    }

    @Override
    public List<Map> getProgressByType(VulnerabilitySearchParameters parameters) {
        assert parameters != null;
        List<Integer> idList = getVulnIdList(parameters);
        if (idList.isEmpty())
            return list();

        List<Map> result = (List<Map>)sessionFactory.getCurrentSession()
                .createQuery(String.format("select new map( " +
                        "avg(%s) as averageAgeOpen, " +
                        "avg(case when vuln.closeTime is null then (%s) " +
                        "when vuln.closeTime is not null then (%s) end) as averageTimeToClose, " +
                        "vuln.genericVulnerability.name as description, " +
                        "vuln.genericVulnerability.id as vulnId, " +
                        "vuln.genericVulnerability.cweId as cweId, " +
                        "vuln.active as status, " +
                        "count(vuln.id) as total " +
                        ") " +
                        "from Vulnerability vuln " +
                        "where vuln.id in (:idList) " +
                        "group by vuln.genericVulnerability.name, vuln.genericVulnerability.id, vuln.genericVulnerability.cweId, vuln.active",
                        getDateDiffSql(":current_timestamp", "vuln.openTime"),
                        getDateDiffSql(":current_timestamp", "vuln.openTime"),
                        getDateDiffSql("vuln.closeTime", "vuln.openTime")))
                .setDate("current_timestamp", new Date())
                .setParameterList("idList", idList)
                .list();

        return result;
    }

    @Override
    public List<Map> getScanComparison(VulnerabilitySearchParameters parameters, boolean isFalsePositive) {
        assert parameters != null;
        List<Integer> idList = getVulnIdList(parameters);

        if (idList.isEmpty())
            return list();

        Session session = sessionFactory.getCurrentSession();
        Criteria criteria = session.createCriteria(Vulnerability.class);

        criteria.createAlias("findings", "finding");
        criteria.createAlias("finding.scan", "scan");
        criteria.createAlias("scan.applicationChannel", "applicationChannel");
        criteria.createAlias("applicationChannel.channelType", "channelType");
        criteria.add(Restrictions.in("id", idList));

        ProjectionList projectionList = Projections.projectionList()
                .add(Projections.groupProperty("channelType.name"), "channelName")
                .add(Projections.alias(Projections.countDistinct("id"), "foundCount"));

        if (!isFalsePositive) {
            projectionList.add(Projections.groupProperty("foundHAMEndpoint"), "foundHAMEndpoint");
        }
        criteria.setProjection(projectionList);
        criteria.addOrder(Order.desc("foundCount"));
        criteria.setResultTransformer(Transformers.ALIAS_TO_ENTITY_MAP);

        List results = (List<Map>)criteria.list();
        return results;
    }

    private List<Integer> getVulnIdList(VulnerabilitySearchParameters parameters) {
        Criteria criteria = VulnerabilitySearchCriteriaConstructor.
                getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters);

        criteria.setProjection(Projections.projectionList()
                .add(Projections.property("id"))
        );

        List<Integer> idList = (List<Integer>) criteria.list();
        return idList;
    }

    @Override
    public Long getCount(VulnerabilitySearchParameters parameters) {
        return (Long) VulnerabilitySearchCriteriaConstructor.getCriteriaWithRestrictions(sessionFactory.getCurrentSession(), parameters)
                .setProjection(Projections.rowCount())
                .uniqueResult();
    }

    private String getDateDiffSql(String toDate, String fromDate) {
        return "(day(" + toDate + ") + " + getDaysOfMonth(toDate) + " + year(" + toDate + ") * 365) -( day(" + fromDate + ") + " + getDaysOfMonth(fromDate) + " + year( " + fromDate + ") * 365)";
    }

    private String getDaysOfMonth(String date) {
        return "case when month(" + date + ") = 1 then 0 " +
                "when month(" + date + ") = 2 then 31 " +
                "when month(" + date + ") = 3 then 59 " +
                "when month(" + date + ") = 4 then 90 " +
                "when month(" + date + ") = 5 then 120 " +
                "when month(" + date + ") = 6 then 151 " +
                "when month(" + date + ") = 7 then 181 " +
                "when month(" + date + ") = 8 then 212 " +
                "when month(" + date + ") = 9 then 243 " +
                "when month(" + date + ") = 10 then 273 " +
                "when month(" + date + ") = 11 then 304 " +
                "when month(" + date + ") = 12 then 334 end";
    }

}
