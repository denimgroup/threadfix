////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2015 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.service.merge;

import com.denimgroup.threadfix.data.entities.*;
import com.denimgroup.threadfix.logging.SanitizedLogger;
import com.denimgroup.threadfix.service.VulnerabilityStatusService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.math.BigInteger;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.ArrayList;
import java.util.List;

@Component
public class VulnerabilityParser {

	private final static SanitizedLogger log = new SanitizedLogger(VulnerabilityParser.class);

	@Autowired
	private VulnerabilityStatusService vulnerabilityStatusService;

	private VulnerabilityParser(){}

	/**
	 * Find the hashed vulnerability ID(s) and put them into a vulnerability
	 * object.
	 *
	 * THIS METHOD REQUIRES THE CHANNEL VULN AND EITHER PARAMETER OR PATH TO
	 * ALREADY BE SET
	 *
	 * @return resulting Vulnerability
	 */
	public Vulnerability parse(Finding finding, boolean remapFinding) {

		if (finding == null) {
			log.warn("Unable to parse a vulnerability due to a null Finding.");
			return null;
		}

		if (finding.getChannelVulnerability() == null) {
			log.warn("The finding did not have a ChannelVulnerability so no vulnerability could be parsed.");
			return null;
		}

		Vulnerability returnVulnerability = null;

		String locationVariableHash, locationHash, variableHash;
		GenericVulnerability genericVulnerability = finding.getChannelVulnerability().getGenericVulnerability();

		if (genericVulnerability == null
				|| genericVulnerability.getName() == null
				|| genericVulnerability.getName().trim().equals("")) {

			log.warn("No generic vulnerability was found for the Channel Vulnerability with code "
					+ finding.getChannelVulnerability().getCode());
			return null;
		}

		Vulnerability vulnerability = new Vulnerability();
		vulnerability.setApplication(finding.getScan().getApplication());

		vulnerabilityStatusService.openVulnerability(vulnerability, finding.getScan(), finding, finding.getScannedDate(), false, remapFinding);
		vulnerability.setGenericVulnerability(genericVulnerability);
		vulnerability.setSurfaceLocation(finding.getSurfaceLocation());

		// TODO calculate some sort of threshold here and figure out whether or not we want to keep
		// the calculated url path or not.
		vulnerability.setCalculatedUrlPath(finding.getCalculatedUrlPath());
		vulnerability.setCalculatedFilePath(finding.getCalculatedFilePath());

		if (finding.isMarkedFalsePositive()) {
			log.info("Creating a false positive vulnerability from a finding marked false positive.");
			vulnerabilityStatusService.markVulnerabilityFalsePositive(vulnerability, finding.getScan(), false, remapFinding);
		}

		String vulnName = genericVulnerability.getName();

		if (finding.getChannelSeverity() != null) {
			vulnerability.setGenericSeverity(getGenericSeverity(finding));
		}

		String param = null;
		if (finding.getSurfaceLocation() != null) {
			param = finding.getSurfaceLocation().getParameter();
		}


		//Set path to '/' if there is no path/parameter in the finding
		if (finding.getSurfaceLocation() != null &&
				(finding.getSurfaceLocation().getPath() == null || finding.getSurfaceLocation().getPath().equals(""))
				&& param == null) {
			finding.getSurfaceLocation().setPath("/");
		} else if (finding.getSurfaceLocation() == null) {
			SurfaceLocation newLocation = new SurfaceLocation();
			newLocation.setPath("/");
			finding.setSurfaceLocation(newLocation);
		}

		if (finding.getSurfaceLocation() != null
				&& finding.getSurfaceLocation().getPath() != null
				&& !finding.getSurfaceLocation().getPath().equals("")) {
			if (param != null) {
				// if we get here, all three variables are present. Hash all of
				// them.
				locationVariableHash = hashFindingInfo(vulnName, finding
						.getSurfaceLocation().getPath(), param);
				locationHash = hashFindingInfo(vulnName, finding
						.getSurfaceLocation().getPath(), null);
				variableHash = hashFindingInfo(vulnName, null, param);
				vulnerability.setLocationVariableHash(locationVariableHash);
				vulnerability.setLocationHash(locationHash);
				vulnerability.setVariableHash(variableHash);
				returnVulnerability = vulnerability;
			} else {
				// if we get here, we just have location and CWE.
				locationHash = hashFindingInfo(vulnName, finding
						.getSurfaceLocation().getPath(), null);
				vulnerability.setLocationHash(locationHash);
				returnVulnerability = vulnerability;
			}
		} else if (param != null) {
			// if we get here, we have variable and CWE
			variableHash = hashFindingInfo(vulnName, null, param);
			vulnerability.setVariableHash(variableHash);
			returnVulnerability = vulnerability;
		} else {
			log.warn("The finding had neither path nor parameter and no vulnerability could be parsed.");
		}

		if (returnVulnerability != null) {
			vulnerability.setFindings(new ArrayList<Finding>());
			vulnerability.getFindings().add(finding);
			finding.setFirstFindingForVuln(true);
			finding.setVulnerability(vulnerability);
		}

		returnVulnerability.setFoundHAMEndpoint(finding.getFoundHAMEndpoint());

		return returnVulnerability;
	}


	/**
	 * Hashes whatever three strings are given to it.
	 *
	 * @param type
	 *            The generic, CWE type of vulnerability.
	 * @param url
	 *            The URL location of the vulnerability.
	 * @param param
	 *            The vulnerable parameter (optional)
	 * @return The three strings concatenated, downcased, trimmed, and hashed.
	 */
	private String hashFindingInfo(String type, String url, String param) {
		StringBuffer toHash = new StringBuffer();

		if (type != null) {
			toHash = toHash.append(type.toLowerCase().trim());
		}

		if (url != null) {
			if (url.indexOf('/') == 0 || url.indexOf('\\') == 0) {
				toHash = toHash.append(url.substring(1).toLowerCase().trim());
			} else {
				toHash = toHash.append(url.toLowerCase().trim());
			}
		}

		if (param != null) {
			toHash = toHash.append(param.toLowerCase().trim());
		}

		try {
			MessageDigest messageDigest = MessageDigest.getInstance("MD5");
			messageDigest.update(toHash.toString().getBytes(), 0,
					toHash.length());
			return new BigInteger(1, messageDigest.digest()).toString(16);
		} catch (NoSuchAlgorithmException e) {
			e.printStackTrace();
			return null;
		}
	}

	public void addToVuln(Vulnerability vuln, Finding finding) {
		vuln.getFindings().add(finding);

		// if finding is dependency then change to generic vulnerability is not 16 Configuration
		if (finding.getDependency() != null) {
			if (finding.getChannelVulnerability() != null
					&& finding.getChannelVulnerability().getGenericVulnerability() != null
					&& finding.getChannelVulnerability().getGenericVulnerability().getDisplayId() != 16
					&& vuln.getGenericVulnerability() != null
					&& vuln.getGenericVulnerability().getDisplayId() == 16)
				vuln.setGenericVulnerability(finding.getChannelVulnerability().getGenericVulnerability());
		}

		// Set Found HAM Endpoint flag to old vulnerability
		if (finding.getFoundHAMEndpoint())
			vuln.setFoundHAMEndpoint(finding.getFoundHAMEndpoint());

		finding.setVulnerability(vuln);
        setHighestSeverity(vuln);

	}

	private void setHighestSeverity(Vulnerability vuln) {

        List<Finding> findings = vuln.getFindings();

        if (findings.size() > 1) {

            GenericSeverity highestGenericSeverity = getGenericSeverity(findings.get(0));

			if (highestGenericSeverity == null) {
				return;
			}

            for (int i = 1; i < findings.size(); i++) {
                Finding finding = findings.get(i);
                GenericSeverity currentFindingSeverity = getGenericSeverity(finding);

				if (currentFindingSeverity == null) {
					continue;
				}

                if (currentFindingSeverity.getIntValue() > highestGenericSeverity.getIntValue()) {
                    highestGenericSeverity = currentFindingSeverity;
                }
            }

            vuln.setGenericSeverity(highestGenericSeverity);
            vuln.setOriginalGenericSeverity(highestGenericSeverity);
        }
	}

	private GenericSeverity getGenericSeverity(Finding finding) {
		GenericSeverity severity = null;

		if (finding != null && finding.getChannelSeverity() == null) {
			log.warn("No Channel Severity found for " + finding.getChannelVulnerability().getName());
		}
		if (finding != null && finding.getChannelSeverity()!= null && finding.getChannelSeverity().getSeverityMap() != null)
			severity = finding.getChannelSeverity().getSeverityMap().getGenericSeverity();

		return severity;
	}

}
