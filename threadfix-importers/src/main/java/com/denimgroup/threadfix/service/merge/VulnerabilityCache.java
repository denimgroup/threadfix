////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2016 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.service.merge;

import com.denimgroup.threadfix.data.entities.Finding;
import com.denimgroup.threadfix.data.entities.GenericVulnerability;
import com.denimgroup.threadfix.data.entities.Vulnerability;

import java.util.*;

import static com.denimgroup.threadfix.CollectionUtils.*;

/**
 * This method keeps Maps of generic IDs and parameters and uses them to get a set of
 * potential matches for each finding that comes through the merge engine.
 * @author mcollins
 *
 */
public class VulnerabilityCache {
	private Map<Integer, Set<Vulnerability>> vulnTypeMap = map();
	private Map<String, Set<Vulnerability>> parameterMap = map();
	private List<Vulnerability> vulns = list();

	// this key can cut down on the number of merge comparisons
	private static String NULL_KEY = "YM[8hynhJvn2fVs(B}twxAjzftcpecQUJYFcHRCBfRvcW";
	// This boolean is set when the guesser should add new vulnerabilities to its list.
	// This should only be used to keep track of new vulnerabilities so it should be ok.
	boolean addVulns = false;
	
	/**
	 * Use this constructor when you don't have an initial set of vulnerabilities but 
	 * will be accumulating them.
	 */
	public VulnerabilityCache() {
		addVulns = true;
	}
	
	/**
	 * Use this constructor when you do have a list of initial vulnerabilities.
	 */
	public VulnerabilityCache(List<Vulnerability> initialVulns) {
		this.vulns = initialVulns;
		addAll(initialVulns);
	}

	public void addAll(Iterable<Vulnerability> vulns) {
		for (Vulnerability vuln : vulns) {
			add(vuln);
		}
	}
	
	public void add(Vulnerability vuln) {
		if (vuln != null) {
			if (addVulns) {
				vulns.add(vuln);
			}
			
			if (vuln.getGenericVulnerability() != null) {
				Integer key = vuln.getGenericVulnerability().getId();
				
				if (!vulnTypeMap.containsKey(key)) {
					vulnTypeMap.put(key, new HashSet<Vulnerability>());
				}
				
				vulnTypeMap.get(key).add(vuln);
			}

			String parameterKey = NULL_KEY;

			if (vuln.getSurfaceLocation() != null && 
					vuln.getSurfaceLocation().getParameter() != null) {
				parameterKey = vuln.getSurfaceLocation().getParameter();
			}
				
			if (!parameterMap.containsKey(parameterKey)) {
				parameterMap.put(parameterKey, new HashSet<Vulnerability>());
			}

			parameterMap.get(parameterKey).add(vuln);
		}
	}
	
	/**
	 * This method returns a collection of Vulnerabilities that match the type and parameter of 
	 * the supplied Finding. This can cut down considerably on processing time.
	 */
	public Iterable<Vulnerability> getPossibilities(Finding finding) {
		
 		if (finding != null && finding.getChannelVulnerability() != null && 
				finding.getChannelVulnerability().getGenericVulnerability() != null && finding.getDependency() == null) {
 			
 			Set<Vulnerability> fromGeneric = 
 					getVulnsWithCommonType(finding.getChannelVulnerability().getGenericVulnerability());
 			
 			Set<Vulnerability> fromParameter;
 			
 			if (finding.getSurfaceLocation() != null && 
 					finding.getSurfaceLocation().getParameter() != null) {
 				fromParameter = getVulnsWithParameter(finding.getSurfaceLocation().getParameter());
 			} else {
 				fromParameter = getVulnsWithParameter(NULL_KEY);
 			}
 			
 			Set<Vulnerability> copySet = setFrom(fromGeneric);

 			copySet.retainAll(fromParameter);

 			return copySet;
		} else {
			return vulns;
		}
	}
	
	private Set<Vulnerability> getVulnsWithParameter(String parameter) {
		Set<Vulnerability> returnList = parameterMap.get(parameter);
		
		if (returnList == null) {
			returnList = set();
		}
		
		return returnList; 
	}

	private Set<Vulnerability> getVulnsWithCommonType(GenericVulnerability genericVulnerability) {
		
		Integer key = genericVulnerability.getId();
		
		Set<Vulnerability> returnList = vulnTypeMap.get(key);
		
		if (returnList == null) {
			returnList = set();
		}
		
		return returnList;
	}

	@Override
	public String toString() {
		return "Cache (" + vulns.size() + " vulnerabilities)";
	}
}
