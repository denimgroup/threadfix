////////////////////////////////////////////////////////////////////////
//
//     Copyright (c) 2009-2016 Denim Group, Ltd.
//
//     The contents of this file are subject to the Mozilla Public License
//     Version 2.0 (the "License"); you may not use this file except in
//     compliance with the License. You may obtain a copy of the License at
//     http://www.mozilla.org/MPL/
//
//     Software distributed under the License is distributed on an "AS IS"
//     basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
//     License for the specific language governing rights and limitations
//     under the License.
//
//     The Original Code is ThreadFix.
//
//     The Initial Developer of the Original Code is Denim Group, Ltd.
//     Portions created by Denim Group, Ltd. are Copyright (C)
//     Denim Group, Ltd. All Rights Reserved.
//
//     Contributor(s): Denim Group, Ltd.
//
////////////////////////////////////////////////////////////////////////
package com.denimgroup.threadfix.importer.update.impl;

import com.denimgroup.threadfix.annotations.MappingsUpdater;
import com.denimgroup.threadfix.data.dao.*;
import com.denimgroup.threadfix.data.entities.*;
import com.denimgroup.threadfix.importer.update.Updater;
import com.denimgroup.threadfix.importer.update.UpdaterConstants;
import com.denimgroup.threadfix.importer.util.IntegerUtils;
import com.denimgroup.threadfix.logging.SanitizedLogger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.Ordered;
import org.springframework.stereotype.Service;
import org.springframework.web.context.support.SpringBeanAutowiringSupport;

import javax.annotation.Nonnull;
import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;

/**
 * Created by mac on 9/12/14.
 */
@MappingsUpdater
@Service
public class ChannelVulnerabilityUpdater extends SpringBeanAutowiringSupport implements Updater, Ordered {

    private static final SanitizedLogger LOG = new SanitizedLogger(ChannelVulnerabilityUpdater.class);

    @Autowired
    private ChannelVulnerabilityDao channelVulnerabilityDao;
    @Autowired
    private ChannelSeverityDao      channelSeverityDao;
    @Autowired
    private GenericVulnerabilityDao genericVulnerabilityDao;
    @Autowired
    private GenericSeverityDao      genericSeverityDao;
    @Autowired
    private ChannelTypeDao          channelTypeDao;

    @Override
    public int getOrder() {
        return 200;
    }

    enum State { TYPE, VULNS, SEVERITIES, NONE }

    @Override
    public void doUpdate(@Nonnull String fileName, @Nonnull BufferedReader bufferedReader) throws IOException {

        LOG.info("Updating channel vulnerabilities from file " + fileName);

        State state = State.NONE;
        String line;

        int vulnsNo = 0;
        int sevsNo = 0;

        ChannelType channelType = null;
        while ((line = bufferedReader.readLine()) != null) {
            if (line.startsWith("type.info")) {
                state = State.TYPE;
            } else if (line.startsWith("type.vulnerabilities")) {
                state = State.VULNS;
            } else if (line.startsWith("type.severities")) {
                state = State.SEVERITIES;
            } else {
                if (state == State.TYPE) {
                    channelType = updateChannelTypeInfo(line);
                    if (channelType == null)
                        LOG.warn("Was unable to update Channel Type info for " + line);
                } else if (state == State.VULNS) {
                    if (channelType != null) {
                        if (!updateChannelVuln(channelType, line))
                            LOG.warn("Was unable to add " + line);
                        else vulnsNo++;
                    }
                } else if (state == State.SEVERITIES) {
                    if (channelType != null) {
                        if (!updateChannelSeverity(channelType, line))
                            LOG.warn("Was unable to add " + line);
                        else sevsNo++;
                    }
                }
            }
        }

        if (channelType != null) {
            LOG.info("Number of vulnerabilites added for " + channelType.getName() + ": " + vulnsNo);
            LOG.info("Number of severities added for " + channelType.getName() + ": " + sevsNo);
        }
    }

    @Override
    public String getFolder() {
        return UpdaterConstants.SCANNERS_FOLDER;
    }

    public ChannelVulnerability createNewChannelVulnerability(String channelVulnerabilityCode,
                                              String channelVulnerabilityName,
                                              GenericVulnerability genericVulnerability,
                                              ChannelType channelType) {
        ChannelVulnerability channelVulnerability = new ChannelVulnerability();
        channelVulnerability.setCode(channelVulnerabilityCode);
        channelVulnerability.setName(channelVulnerabilityName);
        channelVulnerability.setChannelType(channelType);

        VulnerabilityMap map = new VulnerabilityMap();
        map.setMappable(true);
        map.setChannelVulnerability(channelVulnerability);
        map.setGenericVulnerability(genericVulnerability);
        channelVulnerability.setVulnerabilityMaps(Arrays.asList(map));
        channelVulnerabilityDao.saveOrUpdate(channelVulnerability);
        return channelVulnerability;
    }

    public boolean updateChannelVuln(ChannelType channelType, String line) {
        // use comma as separator
        String[] elements = line.split(",");
        if (elements.length < 3)
            return false;

        boolean changed = false;

        String cvName = elements[0];
        String cvCode = elements[1];
        String genericId = elements[2];

        ChannelVulnerability channelVulnerability = channelVulnerabilityDao.retrieveByCode(channelType, cvCode);

        Integer genericIdInt = IntegerUtils.getIntegerOrNull(genericId);

        if (genericIdInt == null) {
            LOG.warn("Failed to parse generic ID " + genericId);
        } else {
            GenericVulnerability genericVulnerability = genericVulnerabilityDao.retrieveByDisplayId(genericIdInt);

            if (genericVulnerability == null) {
                LOG.warn("Unable to find Generic Vulnerability for GenericId " + genericId);
                changed = false;
            } else {
                if (channelVulnerability != null) {
                    // Update
                    changed = updateChannelVulnerability(channelVulnerability, cvName, genericVulnerability);
                } else {
                    createNewChannelVulnerability(cvCode, cvName, genericVulnerability, channelType);
                    changed = true;
                }
            }
        }

        return changed;
    }

    private boolean updateChannelVulnerability(ChannelVulnerability channelVulnerability,
                                               String channelVulnerabilityName,
                                               GenericVulnerability genericVulnerability) {
        boolean changed = false;

        if (!channelVulnerability.getName().equalsIgnoreCase(channelVulnerabilityName)) {
            channelVulnerability.setName(channelVulnerabilityName);
            changed = true;
        }
        if (channelVulnerability.getGenericVulnerability() == null ||
                channelVulnerability.getGenericVulnerability().getId().equals(genericVulnerability.getId())) {

            if (channelVulnerability.getGenericVulnerability() != null) {
                for (VulnerabilityMap map: channelVulnerability.getVulnerabilityMaps()) {
                    map.setChannelVulnerability(null);
                }
            }

            VulnerabilityMap map = new VulnerabilityMap();
            map.setMappable(true);
            map.setChannelVulnerability(channelVulnerability);
            map.setGenericVulnerability(genericVulnerability);
            channelVulnerability.setVulnerabilityMaps(Arrays.asList(map));
            channelVulnerabilityDao.saveOrUpdate(channelVulnerability);
            changed = true;
        }

        return changed;
    }

    public boolean updateChannelSeverity(ChannelType channelType, String line) {
        // use comma as separator
        String[] elements = line.split(",");
        if (elements.length < 4)
            return false;

        String csName = elements[0];
        String csCode = elements[1];
        String csNumericValue = elements[2];
        String genericSeverityId = elements[3];
        ChannelSeverity cs = channelSeverityDao.retrieveByCode(channelType,csCode);

        try {
            if (cs == null) {
                cs = new ChannelSeverity();
                cs.setCode(csCode);
            }
            cs.setName(csName);
            cs.setChannelType(channelType);
            cs.setNumericValue(Integer.valueOf(csNumericValue));
            GenericSeverity gs = genericSeverityDao.retrieveByIntValue(Integer.valueOf(genericSeverityId));
            if (gs == null) {
                LOG.warn("Unable to find Generic Severity for SeverityId " + genericSeverityId);
                return false;
            }
            SeverityMap map = cs.getSeverityMap();
            if (map == null)
                map = new SeverityMap();
            map.setChannelSeverity(cs);
            map.setGenericSeverity(gs);
            cs.setSeverityMap(map);
            channelSeverityDao.saveOrUpdate(cs);
            return true;
        } catch (NumberFormatException e) {
            LOG.warn("Numberic Value  " + csNumericValue + " or " + genericSeverityId + " is not a number");
        }

        return false;
    }

    public ChannelType updateChannelTypeInfo(String line) {

        ChannelType channelType = null;
        // use comma as separator
        String[] elements = line.split(",");
        if (elements.length > 0) {

            String name = elements[0];
            channelType = channelTypeDao.retrieveByName(name);

            if (channelType == null) {
                if (elements.length < 4) {
                    LOG.error("Channel type information has " + elements.length + " sections instead of 4.");

                } else {
                    LOG.info("Creating new Channel Type " + name);
                    channelType = new ChannelType();
                    channelType.setName(name);
                    channelType.setUrl(elements[1]);
                    channelType.setVersion(elements[2]);
                    channelType.setExportInfo(elements[3]);

                    channelTypeDao.saveOrUpdate(channelType);
                }
            }
        }

        return channelType;
    }


}
