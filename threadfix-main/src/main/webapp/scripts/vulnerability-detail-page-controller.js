var myAppModule = angular.module('threadfix')

myAppModule.controller('VulnerabilityDetailPageController', function ($scope, $window, $http, $rootScope, tfEncoder, $modal, $log, vulnSearchParameterService) {

    $scope.vulnId  = $window.location.pathname.match(/vulnerabilities\/([0-9]+)/)[1];
    $scope.teamId = $window.location.pathname.match(/organizations\/([0-9]+)/)[1];
    $scope.appId = $window.location.pathname.match(/applications\/([0-9]+)/)[1];
    $scope.currentUrl = "/organizations/" + $scope.teamId + "/applications/" + $scope.appId + "/vulnerabilities/" + $scope.vulnId;
    $scope.canUpdateVulnComment = true;
    $scope.badgeClassMap = {
            5:"badge-critical",
            4:"badge-high",
            3:"badge-medium",
            2:"badge-low",
            1:"badge-info"
    };

    $scope.toggle = function(finding) {
        if (typeof finding.expanded === "undefined") {
            finding.expanded = false;
        }
        finding.expanded = !finding.expanded;
    };

    $scope.$on('rootScopeInitialized', function() {

        $scope.refresh();
    });

    $scope.showInfo = function() {
        if ($scope.isShowInfo) {
            $scope.isShowInfo = false;
            $scope.toggleBtnText = 'Toggle More Info';
        } else {
            $scope.isShowInfo = true;
            $scope.toggleBtnText = 'Toggle Hide Info';
        }
    };

    $scope.openCommentModal = function() {

        var modalInstance = $modal.open({
            templateUrl: 'vulnCommentForm.html',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return tfEncoder.encode($scope.currentUrl + "/addComment");
                },
                object: function () {
                    return {};
                },
                config: function() {
                    return {tags: $scope.tags};
                },
                buttonText: function() {
                    return "Add Comment";
                }
            }
        });

        modalInstance.result.then(function (comments) {
            $scope.successMessage = "Successfully added new comment";
            $scope.vulnerability.vulnerabilityComments = comments;
            vulnSearchParameterService.updateVulnCommentTags($scope.tags, $scope.vulnerability);

            if ($scope.vulnerability.vulnerabilityComments) {
                $scope.vulnerability.vulnerabilityComments.forEach(function(comment) {
                    comment.commentChanged = false;
                });
            }

        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    };

    $scope.openEditFindingModal = function(finding) {

        var modalInstance = $modal.open({
            templateUrl: 'editManualFindingForm.html',
            windowClass: 'wide',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return tfEncoder.encode($scope.currentUrl + "/manual/" + finding.id + "/edit");
                },
                object: function() {
                    if (!finding.dataFlowElements || finding.dataFlowElements.length === 0) {
                        finding.dataFlowElements = [{}];
                    }
                    var findingCopy = angular.copy(finding);
                    findingCopy.id = null;
                    $scope.config.manualSeverities.forEach(function(severity) {
                        if (severity.name === finding.channelSeverity.name) {
                            findingCopy.channelSeverity = severity;
                        }
                    });
                    return findingCopy;
                },
                config: function() {
                    return $scope.config;
                },
                buttonText: function() {
                    return "Submit Finding";
                }
            }
        });

        $scope.currentModal = modalInstance;

        modalInstance.result.then(function (result) {
            $scope.vulnId = result.id;
            $scope.currentUrl = "/organizations/" + $scope.teamId + "/applications/" + $scope.appId + "/vulnerabilities/" + result.id;
            $scope.refresh();
            $scope.successMessage = "Finding has been edited.";
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });


    };

    $scope.openEditDescriptionModal = function(finding, index) {

        var modalInstance = $modal.open({
            templateUrl: 'editDescriptionFindingForm.html',
            windowClass: 'wide',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return tfEncoder.encode($scope.currentUrl + "/findings/" + finding.id + "/editDescription");
                },
                object: function() {
                    return angular.copy(finding);
                },
                config: function() {
                    return $scope.config;
                },
                buttonText: function() {
                    return "Submit Description";
                }
            }
        });

        $scope.currentModal = modalInstance;

        modalInstance.result.then(function (result) {
            result.expanded = true;
            $scope.findings[index] = result;
            $scope.successMessage = "Finding has been edited.";
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });


    };

    var getFindingUrl = function(finding) {
        return tfEncoder.encode("/organizations/" + $scope.teamId + "/applications/" + $scope.appId + "/scans/" + finding.scanId + "/findings/" + finding.id);
    };

    $scope.toggleFinding = function(finding) {
        $scope['isShowFlow' + finding.id] = $scope['isShowFlow' + finding.id] ? false : true;
    };

    $scope.refresh = function() {
        $http.get(tfEncoder.encode($scope.currentUrl + '/table')).
            success(function(data, status, headers, config) {

                if (data.success) {
                    $scope.vulnerability = data.object.vulnerability;
                    $scope.documents = data.object.vulnerability.documents;
                    $scope.findings = data.object.vulnerability.findings;
                    $scope.surfaceLocation = data.object.surfaceLocation;
                    $scope.singleStaticFinding = data.object.singleStaticFinding;
                    $scope.staticFindingList = data.object.staticFindingList;
                    $scope.tags = data.object.tags;
                    $scope.vulnTags = data.object.vulnTags;
                    vulnSearchParameterService.updateVulnCommentTags($scope.tags, $scope.vulnerability);

                    $scope.config = data.object;
                    if (!$scope.config.recentFileList) {
                        $scope.config.recentFileList = [];
                    }
                    if (!$scope.config.recentPathList) {
                        $scope.config.recentPathList = [];
                    }

                    $scope.links = [];
                    if ($scope.vulnerability.findings) {
                        $scope.vulnerability.findings.forEach(function(finding) {
                            if (finding.urlReference) {
                                $scope.links.push({
                                    "scannerName" : finding.scannerName,
                                    "urlReference" : finding.urlReference
                                });
                            }
                            finding.pageUrl = getFindingUrl(finding);
                        });
                    }

                    if ($scope.vulnerability.vulnerabilityComments) {
                        $scope.vulnerability.vulnerabilityComments.forEach(function(comment) {
                            comment.commentChanged = false;
                        });
                    }

                    $scope.showActionButton = data.object.canModifyVulnerabilities
                        || (data.object.canSubmitDefects && $scope.vulnerability.app.defectTracker)
                        || $scope.vulnerability.defect

                } else {
                    $scope.errorMessage = "Failure. Message was : " + data.message;
                }
            }).
            error(function(data, status, headers, config) {
                $scope.errorMessage = "Failed to retrieve waf list. HTTP status was " + status;
            });
    };
    
    $scope.updateVulnComment = function(vulnerability, comment){
        if (!comment.commentChanged || comment.commentChanged == undefined) {
            return;
        }

        $http.post(tfEncoder.encode($scope.currentUrl + '/vulnComments/' + comment.id + "/update"), comment).
            success(function(data, status, headers, config) {

                if (data.success) {
                    $scope.successMessage = "Successfully updated comment";
                    comment.commentChanged = false;
                } else {
                    $scope.errorMessage = "Failure. Message was : " + data.message;
                }
            }).
            error(function(data, status, headers, config) {
                $scope.errorMessage = "Failed to retrieve waf list. HTTP status was " + status;
            });
    }

    $scope.changeComment = function(comment){
        comment.commentChanged = true;
    }

    $scope.resetComment = function(comment){
        comment.commentChanged = false;
    }

    $scope.goToTag = function(tag) {
        window.location.href = tfEncoder.encode("/configuration/tags/" + tag.id +"/view");
    }

    $scope.tagVuln = function(tags) {

        var filteredVulns = [$scope.vulnerability];
        var modalInstance = $modal.open({
            templateUrl: 'vulnTaggingForm.html',
            controller: 'ModalControllerWithConfig',
            resolve: {
                url: function() {
                    return tfEncoder.encode("/organizations/" + $scope.vulnerability.team.id + "/applications/" + $scope.vulnerability.app.id + "/addBatchVulnTagging");
                },
                object: function () {
                    return {vulnerabilityIds : filteredVulns.map(function(vuln) {
                        return vuln.id;
                    })};
                },
                config: function() {
                    return {tags: tags};
                },
                buttonText: function() {
                    return "Tag Vulnerability";
                }
            }
        });

        $scope.currentModal = modalInstance;

        modalInstance.result.then(function (selectedTags) {
            filteredVulns.forEach(function(vuln){
                vuln.tags = selectedTags;
            });
            $log.info("Successfully tagged to vulnerability.");
            $scope.successMessage = "Successfully tagged to vulnerability.";
        }, function () {
            $log.info('Modal dismissed at: ' + new Date());
        });
    };


});
